# (Не)очевидные трюки отладки фронтенда
*фото c фронтендером, кидающим девайсы / Firefox и Chrome лого / что-нибудь еще*

Так получается, что большую часть времени разработчик тратит на отладку кода.
Поэтому нужно уметь это делать, и делать это хорошо.
Что бы вы могли сказать про отладку и фронтенд? Конечно же _console.log_, _debugger_ и еще десяток классных штук из DevTools. Теперь вы знаете о чем будет половина этого текста ツ  
А за остальным интригующе приглашаю под кат!

### Дисклеймер
Все будет в коротком виде – описание с применением. Многие трюки весьма просты, но это не является показателем их бесполезности.
Подробности специально убраны под спойлер, чтобы туда смотрели только если этот трюк неизвестен.

Приведенные примеры были сделаны в [Chrome Canary](https://www.google.com/chrome/browser/canary.html) и [Firefox Developer Edition](https://www.mozilla.org/en-US/firefox/developer/), поэтому лучше установить эти версии браузеров. Так вы сможете уже сейчас пользоваться тем, что в стабильной версии появится только через 3 месяца.

#### Редактирование кода в браузере
Представим что мы столкнулись с проблемой на лайве и изменять скрипты на сервере нет возможности. В таком случае мы можем попробовать изменить код до выполнения (и даже во время выполнения) в Chrome.  
Для этого нужно поставить точку останова до интересующего нас кода, внести необходимые изменения, сохранить и продолжить выполнение.

Я сделал [демку](http://reepush.github.io/publications/obvious-frontend-debugging-tricks/demos/live-edit/live-edit.html). Попробуйте ее пройти не заглядывая под спойлер.

>  
Как пройти демо:

1. Находим скрипт _live-edit.js_ и ставим точку останова на строке 1
2. Перезагружаем страницу
3. Выполнение останавливается и мы можем изменить значение переменной `isItEasy` на `true`
4. После сохраняем (`Ctrl` + `S`)
5. Продолжаем выполнение

>  
![](http://reepush.github.io/publications/obvious-frontend-debugging-tricks/images/live-edit.gif)

>  
Работает очень магически, ни один браузер кроме Chrome так делать не умеет. А именно – при изменении весь код в текущем контексте выполняется заново. Это нужно учитывать, ведь в некоторых случаях функции могут изменять внешнее состояние и лишние изменения будут нежелательными.  
Пример такого поведения можно посмотреть в [этом демо](http://reepush.github.io/publications/obvious-frontend-debugging-tricks/demos/live-edit/live-edit-scoping.html). Обратите внимание что после изменения кода в консоли появится _IIFE executed 2 time_.

К сожалению с этим способом нельзя сохранить наши изменения при перезагрузке.
Для чего-то более сложного лучше использовать прокси.

#### Подмена скриптов через прокси
Мы все так же на лайве, без доступов к скриптам. По сравнению с предыдущим примером нам нужно сделать более масштабные изменения или может быть еще необходим препроцессинг нашего кода.  
Будем делать все изменения локально и подменять скрипты с помощью BrowserSync. В [примере](https://gist.github.com/reepush/5d9bb62112b4bf183926) будет подключен наш скрипт и стили на главную страницу Яндекса.

>  
Клонируем пример, устанавливаем зависимости и запускаем:
```
git clone https://gist.github.com/5d9bb62112b4bf183926.git proxify-assets
cd proxify-assets
npm install
gulp
```
Теперь заходим на [https://localhost:3000/](https://localhost:3000/) и видим всем знакомую страницу. Но только у нас еще подключено два файла: _custom.css_ и _custom.js_. Попробуйте их изменить – BrowserSync автоматически перезагрузит страницу при изменении скрипта, а изменения стилей применятся мгновенно без перезагрузки.  
В этом примере мы не заменяли внешние скрипты на локальные, но это очень просто сделать лишь изменив _rewriteRules_ в настройках BrowserSync.

#### Подмена страниц в WebView
Для отладки девайсов нужно собрать специальный билд приложения, который позволит подключиться инспектором к WebView. У нас сборка может быть для лайва или стейджинга, а в таком случае нет возможности быстро вносить изменения и видеть результат.  
Но мы можем подключиться инспектором и выполнить в консоли `window.location.href = 'http://your-dev.local'` и делать быстрые итерации на локальном окружении.

>  
Для Android девайсов подключиться инспектором можно только начиная с версии 4.4. В более старых версиях стоит попробовать воспроизвести проблему в браузере. Тут могут помочь трюки _Вылезаем из локальной сети_ и _Эмулятор Android девайсов_.

#### Отладка с помощью Valence
Valence является адаптером к различным браузерам (Safari на iOS, Firefox на Android, Chrome), приводящим различные протоколы к единому виду. Таким образом можно всегда использовать привычный инструмент для отладки, либо же сделать его привычным ツ  
Более подробно посмотреть как использовать WebIDE вместе с Valence можно на [MDN](https://developer.mozilla.org/en-US/docs/Tools/WebIDE/Setting_up_runtimes).

>  
C Chrome так же можно подключаться к iOS, но по сравнению с WebIDE это выглядит довольно сложно.  
Хочу заметить что пока это больше экспериментальная возможность и работает не совсем стабильно. Но мне один раз пригодилась, когда нужно было заглянуть в Safari, а системы с Mac OS не было под рукой.
Надеюсь что в будущем протоколы отладки будут стандартизированы, и мы сможем пользоваться своими любимыми инструментами для отладки Node.js, например.

#### Вылезаем из локальной сети
С отладкой на различных браузерах и девайсах все просто – мы всегда имеем доступ к локальной сети. Все бы так и было, если бы не Опера Мини. Все запросы делаются с удаленных серверов Оперы, которым наши локальные ресурсы недоступны. Тут нам пригодится _[ngrok](https://ngrok.com/)_, либо _SSH-туннель_ если у нас есть свой хост.

>  
###### Используем ngrok
`ngrok http localhost:8000`  
Чтобы отдать наши локальные файлы мы можем использовать удобный `python -m SimpleHTTPServer`   
Но если мы хотим вынести наружу не просто статику, а сервер, то скорее всего пригодится такой параметр как `host-header`. Все вместе будет выглядеть так:  
`ngrok http -host-header=your-dev.local your-dev.local:80`
>
###### Используем SSH-туннель
`ssh -NR 0.0.0.0:8080:your-dev.local:80 your-host.external`  
После этого обращаясь по адресу http://your-host.external:8080/ мы будем иметь доступ к локальному хосту.  
Тут еще нужно не забыть про конфиг */etc/ssh/sshd_config*. Более подробно об этом можно посмотреть [здесь](http://blog.trackets.com/2014/05/17/ssh-tunnel-local-and-remote-port-forwarding-explained-with-examples.html), но если кратко – нужно указать следующий параметр на сервере:  
`GatewayPorts clientspecified`

#### Букмарклет для повторяющихся действий
Мы делаем изменения и тестируем их, делаем изменения, опять тестируем... А тестирование в некоторых случаях весьма затратно по времени. Можно заскриптовать наши действия и выполнять их как букмарклет одним кликом.  
В [этом примере](http://localhost:8000/bookmarklet-fill-form/bookmarklet-fill-form.html) нужно заполнить необходимые параметры, указав форму и нужные значения. Сразу после изменения мы можем перетащить ссылку `Fill Form` к себе на панель закладок и с помощью нее заполнять свои формы.

#### Воспроизводим как тестировщики
Я уверен что всем хотелось бы как можно меньше времени тратить на чтение _Steps To Reproduce_, а сразу увидеть проблему и приступить к ее решению. Как например, если тестировщик сидит рядом с нами и передает ноутбук как только обнаруживает проблему.  
Попробуем зафиксировать это состояние. Что мы можем сохранить:
* Ссылку
* Куки
* Юзер-агент
* Стек трейс
* Разметку

[Пример букмарклета](http://reepush.github.io/publications/obvious-frontend-debugging-tricks/demos/bookmarklet-reproducible/bookmarklet-reproducible.html), который это делает. После нажатия на _Run reproducible_, появится снизу кнопка _Copy Info_, нажав на которую мы получим всю необходимую информацию.

Это нужно сделать расширением к браузеру. Потому что с букмарклетом я уже вижу как минимум две проблемы, которые никак нельзя решить: логирование исключений до активации букмарклета и получение HttpOnly кук. Так что пока это просто набросок идеи, но может быть уже есть подобные решения?

#### Эмулятор Android девайсов
Как-то мне один специалист по тестированию показал прекрасный инструмент для эмуляции – [Genymotion](https://www.genymotion.com/).
Там более 80 вариаций девайсов и версий, есть из чего выбрать. Мы так смогли воспроизвести баг возникающий на версии 4.3, а таких девайсов у нас не было.

#### Mixed Content
Полезно помнить о возможности возникновения этой проблемы. Был такой случай:
> На Android девайсе в приложении всегда загружается плейсхолдер, а не картинка товара. На десктопе и мобильной версии не воспроизводится. Плейсхолдер вешается при событии `error`, то есть когда произошла ошибка загрузки.

Проблема с сетью у тестировщика и _Can't reproduce_?  
Но оказалось что приложение открывает страницу по HTTPS протоколу, а картинка загружается по обычному HTTP.  
Отлично если бы срабатывал верный триггер на такого рода проблемы.

#### DevTools для самых внимательных
Описание      |  Скриншот
------------- | -------------
_Пропускаем точки останова в текущем тике в Chrome_ | ![](http://reepush.github.io/publications/obvious-frontend-debugging-tricks/images/next-tick.png?1)
_Подсветка измененных стилей в Firefox_ | ![](http://reepush.github.io/publications/obvious-frontend-debugging-tricks/images/changed-styles.png?1)
_Переключение классов в Chrome_ | ![](http://reepush.github.io/publications/obvious-frontend-debugging-tricks/images/toggle-class.png?1)
_Изменение способа описания цвета (Shift + клик)_ | ![](http://reepush.github.io/publications/obvious-frontend-debugging-tricks/images/color-types.png?1)
_Обращение к выделенному элементу в инспекторе через `$0` (кое-кто не знал)_ | ![](http://reepush.github.io/publications/obvious-frontend-debugging-tricks/images/selected-element.png?1)
_Скрытие элемента по хоткею `H` и скролл по `S`_ |

На этом все. А если вы знаете другие полезные трюки – обязательно поделитесь ими в комментариях!
